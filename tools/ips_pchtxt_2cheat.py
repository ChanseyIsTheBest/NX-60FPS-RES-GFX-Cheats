import binascii
import os
import struct
import sys
import array
import re

HEAD_MAGIC_SIZE = 5
IPS_HEAD_MAGIC = bytearray("PATCH", 'ascii')
IPS32_HEAD_MAGIC = bytearray("IPS32", 'ascii')

IPS_ADDRESS_SIZE = 3
IPS32_ADDRESS_SIZE = 4
IPS_FOOT_MAGIC = bytearray("EOF", 'ascii')
IPS32_FOOT_MAGIC = bytearray("EEOF", 'ascii')

IPS_PATCH_LEN_STRUCT = struct.Struct('>H')

NSO_HEADER_LEN = 0x100

CHEAT_EXT = ".txt"
CHEAT_ENCODING = "ascii"
CHEAT_TYPE = "04000000" # A cheat for just writing a static value to a main address

CHEAT_HEADER = f"// auto generated by ips2cheat\n\n"
PATCH_TEXT_ADDRESS_STRUCT = struct.Struct('>I')

def swap_endianness(hex_bytes: bytes):
    hex_str = hex_bytes.hex()
    hex_str_array = []
    for i in range(0, len(hex_str), 4):
        hex_str_array.append(hex_str[i:i+4])
    hex_str_array.reverse()
    hex_str = "".join(hex_str_array)
    return binascii.unhexlify(hex_str)

def swap_endianness_str(hex_str: str):
    hex_str_array = []
    for i in range(0, len(hex_str), 2):
        hex_str_array.append(hex_str[i:i+2])
    hex_str_array.reverse()
    hex_str = "".join(hex_str_array)
    return hex_str

def ips2cheat(ips_path, cheat_name, out_cheat_path):
    ips_file = open(ips_path, 'rb')
    cur_head_magic = ips_file.read(HEAD_MAGIC_SIZE)
    if cur_head_magic == IPS_HEAD_MAGIC:
        cur_address_size = IPS_ADDRESS_SIZE
        cur_foot_magic = IPS_FOOT_MAGIC
    elif cur_head_magic == IPS32_HEAD_MAGIC:
        cur_address_size = IPS32_ADDRESS_SIZE
        cur_foot_magic = IPS32_FOOT_MAGIC
    else:
        print("Not an ips file")
        return -1

    ips_name = os.path.basename(ips_path)
    ips_name_no_ext = os.path.splitext(ips_name)[0]
    
    if out_cheat_path:
        out_cheat_file = open(out_cheat_path, 'wb+')
    else:
        out_cheat_file = open(ips_name_no_ext[:16] + CHEAT_EXT, 'wb+')
    print(f"Writing to {out_cheat_file.name}")
    out_cheat_file.write(CHEAT_HEADER.encode(CHEAT_ENCODING))
    out_cheat_file.write(f"[{cheat_name}]\n".encode(CHEAT_ENCODING))

    while True:
        cur_address_bytes = ips_file.read(cur_address_size)
        if cur_address_bytes == cur_foot_magic:
            break

        cur_address = 0
        for exponent in range(cur_address_size):
            cur_address += cur_address_bytes[cur_address_size -
                                             1 - exponent] << (exponent * 8)
        cur_address -= NSO_HEADER_LEN

        cur_len = IPS_PATCH_LEN_STRUCT.unpack(
            ips_file.read(IPS_PATCH_LEN_STRUCT.size))[0]
        cur_value = ips_file.read(cur_len)

        out_cheat_file.write(CHEAT_TYPE.encode(CHEAT_ENCODING))
        out_cheat_file.write(" ".encode(CHEAT_ENCODING))
        out_cheat_file.write(binascii.b2a_hex(
            PATCH_TEXT_ADDRESS_STRUCT.pack(cur_address)).upper())
        out_cheat_file.write(" ".encode(CHEAT_ENCODING))
        out_cheat_file.write(swap_endianness(
            binascii.b2a_hex(cur_value).upper()))
        out_cheat_file.write("\n".encode(CHEAT_ENCODING))

    out_cheat_file.close()

def pchtxt2cheat(pchtxt_path, cheat_name, out_cheat_path):
    pchtxt_file = open(pchtxt_path, 'rt')

    pchtxt = pchtxt_file.read()
    bidMatch = re.match(r"@nsobid-(.+)", pchtxt)
    if bidMatch:
        bid = bidMatch.group(1)
    else:
        print("Could not find bid in pchtxt file, the file is likely invalid.")
        return

    if out_cheat_path:
        out_cheat_file = open(out_cheat_path, 'wb+')
    else:
        out_cheat_file = open(bid[:16] + CHEAT_EXT, 'wb+')

    print(f"Writing to {out_cheat_file.name}")
    out_cheat_file.write(CHEAT_HEADER.encode(CHEAT_ENCODING))
    out_cheat_file.write(f"[{cheat_name}]\n".encode(CHEAT_ENCODING))

    offset = 0 

    for line in pchtxt.splitlines():
        offsetMatch = re.match(r"@flag offset_shift (0x)?([0-9]+)", line)
        if offsetMatch:
            if offsetMatch.group(1):
                offset = int(offsetMatch.group(2), 16) - 0x100 # Cheats will normally have an offset of 0x100 to be in main, this is to account for that
            else:
                offset = int(offsetMatch.group(2)) - 0x100
            continue

        codeMatch = re.match(r"^([0-9A-Fa-f]+) ([0-9A-Fa-f]+)", line)
        if codeMatch:
            codeOffset = int(codeMatch.group(2), 16) + offset

            out_cheat_file.write('04000000 '.encode(CHEAT_ENCODING))
            out_cheat_file.write(codeMatch.group(1).encode(CHEAT_ENCODING))
            out_cheat_file.write(' '.encode(CHEAT_ENCODING))
            out_cheat_file.write(swap_endianness_str(f'{codeOffset:0>8X}').encode(CHEAT_ENCODING))
            out_cheat_file.write('\n'.encode(CHEAT_ENCODING))

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: ips2cheat.py <ips_path> [cheat_name] [cheat_file_path]")
    else:
        cheat_name = "Cheat"
        out_cheat_path = None
        ips_path = sys.argv[1]
        if len(sys.argv) > 2:
            cheat_name = sys.argv[2]
        if len(sys.argv) > 3:
            out_cheat_path = sys.argv[3]
        if(ips_path.endswith(".pchtxt")):
            pchtxt2cheat(ips_path, cheat_name, out_cheat_path)
        else:
            ips2cheat(ips_path, cheat_name, out_cheat_path)